package byteIndexof;

import java.util.Arrays;

/**
 * Similar to a last byte matcher, except this matches two bytes at once.  Normally this
 * would require a shift table of 65536 entries, but with some hashing of the two bytes
 * involved, the table can be kept small.  If there is a hash collision for two pairs of
 * bytes, the most conservative shift value is stored in the table.<p>
 *
 * Performance improves with a larger hash table, or potentially a better hashing
 * algorithm (currently it shifts one of the bytes and xors it with the other).
 *
 * @author John Hendrikx
 */
public class TwoByteHashShiftMatcher extends MatcherFactory
{
    static long neq_ind_sum = 0;
    static long compare_count = 0;

    /**
     * Controls how much memory is allocated for hash table, 0 = 1kB, 1 = 2kB, 2 = 4kB, etc.
     *
     * Generally, higher is better, until caches can't hold the table.
     */
    private static int p2 = 4;

    private static final class MatcherImpl extends Matcher
    {
        private final byte[] pattern;
        private final int[] shifts;

        public MatcherImpl(byte [] pattern, int[] shifts) {
            this.pattern = pattern;
            this.shifts = shifts;
        }

        @Override
        public int indexOf (byte[] text, int fromIdx) {
            int pattern_len = pattern.length;
            int text_len = text.length;
            int offset = pattern_len - 1;
            int i = fromIdx + offset;
            int maxLen = text_len - pattern_len + offset;

            while(i < maxLen) {
              int hash = ((text[i - 1] & 0xff) << p2) ^ (text[i] & 0xff);
              int skip = shifts[hash];

              if(skip == 0) {  // No skip, let's compare
                if(compare (text, i - offset, pattern, pattern_len)) {
                  return i - offset;
                }
                i++;  // Compare failed, move ahead 1.
              }

              i += skip;  // Can be done always, if skip was zero it does nothing.
            }

            return -1;
        }
    }

    @Override
    public Matcher createMatcher (byte[] pattern)
    {
      int[] shifts = new int[256 << p2];

      Arrays.fill(shifts, pattern.length - 1);  // Fill hash table with the maximum allowed shift for all entries

      // Overwrite entries part of the pattern with lower shift values:
      for(int j = pattern.length - 2; j >= 0; j--) {
        int shift = pattern.length - 2 - j;
        int hash = ((pattern[j] & 0xff) << p2) ^ (pattern[j + 1] & 0xff);

        if(shifts[hash] > shift) {  // Because there can be collisions in the hash, take the most conservative shift value
          shifts[hash] = shift;
        }
      }

      return new MatcherImpl(pattern, shifts);
    }

    @Override
    public String stats ()
    {
        if (compare_count == 0) {
            return "";
        }
        double avg = neq_ind_sum * 1.0 / compare_count;
        compare_count = neq_ind_sum = 0;
        return String.format ("; avg neq index = %5.2f", avg);
    }
}
